zjx20、driver、arthuryang等几位大神的代码确实漂亮，让人眼前一亮。我先写写我的思路，给大家抛砖引玉。

我是在V2上看到@mickeyandkaka的帖子过来的，说这边高手如云，我就过来跟高手学习学习。

我理解这期赛码会要求写的是一个基于内存、磁盘两级存储的哈希表，有内存和磁盘用量的限制，我就从这三方面记一下我的思路。

###哈希表构造

一个哈希表数据结构主要有三块儿内容，哈希函数、哈希表（这里指存储槽位的表）和记录。

哈希函数有很多可选，FNV-1、CityHash等，我用了CRC和MurmurHash，对，CRC除了做校验，用作哈希效果也不错。试下来CRC和MurmurHash的冲突率都很低，性能上两者也是在伯仲之间。

哈希表中槽位数的多少直接影响装载因子，我倾向于浪费点内存降低装载因子。代码中创建了2^22个槽位，每个槽位放一个int，算下来大小总共16M，还是可以接受的。将哈希值映射到槽位也有多种方法，用mod取模或者乘法散列法等。我的哈希表刚好对应22位的地址空间，于是采取了将32位哈希值直接折叠到22位的方法，在fold函数中实现。解决冲突用的是简单的链地址法，因为装载因子比较低，用开放寻址法我认为也不会有什么问题。

记录中主要存的是value的值，还要存key的长度、value的长度等，对应struct rec。value的值可以很长而且是变长的，因此可以有几种不同的处理方式：

1. 按value的最大长度将value放在结构体内

1. 将value单独拿出来，按实际长度顺序存储

1. 将value单独拿出来，按最大长度顺序存储

方式1适合value比较短的场景，方式2、3适合value较长的场景；方式1、3在遇到对已存在key的大量update的时候能够方便地复写原value的存储区，而方式2只能分配新存储区；方式2需要在结构体中记录value的偏移量，方式3中如果value存储区的分配跟结构体的分配同步则可以直接算出地址；方式2、3容易将大量put实现为顺序写，方式1随机写的比率会比较高。综合来看，因small数据集的数据量比较小，能全部放在内存中，用方式1或3是比较合适的。我现在贴的代码中Middle和Large数据集用的是方式2，为Middle写过一个用方式3的实现，一直报RuntimeError，后来没有去管了。

###存储结构

前面三部分内容，哈希函数在可执行文件中，记录肯定是要我们存储到磁盘的，哈希表则可存可不存，如果不存需要在构造函数中重建。

贴出的对应small数据集的代码是没有存储哈希表的，在restoreIndexFromFile函数中重建，而对应Middle和Large数据集的代码是存储了哈希表的，大小为IDXSIZE的部分。

我将哈希表和记录存储到了一个文件里，分开写到两个或三个文件中当然也没问题。文件分为三个区域，前两个区域的大小依次为POOLSIZE和IDXSIZE，分别存储struct rec和哈希表，第三个区域存储value的值。

每次重启程序后映射地址会变，因此哈希表和struct rec的next字段中存储的都是相对地址。如果在mmap调用中指定要映射到的虚存地址，那么这里写绝对地址也是可以的，不过到现在我还没试过。

###内存结构

内存结构比较简单，哈希表和struct rec都通过mmap映射到内存，分别对应idx和ppool。映射一段MCW大小的区域cch，用于向文件尾追加写value值，写完一段就重新映射到下一段，滚动向前。

对于已存在key的update，我前期的代码中会往前找到原value的存储区，如果存储区够大就复写在该区域，否则写到文件尾，现在贴的代码中只会去检查是不是新旧value相同，其他情况一律写到文件尾，这样做是考虑避免大量重复键值对的put请求让文件快速膨胀，但是测试数据中貌似没有这样的场景。

对于剩下的内存，全部用作对存储value值的文件区域的缓存，代码中是cchf，大小为MC。这样做缓存非常简单，对于update请求不多的场景效果还是不错的，但是update请求很多的话，新的value被追加到文件尾，前面的value大量失效，这时缓存的效率就不高了。另外，这样缓存的是存在文件中的一串char，命中的时候返回string，仍然需要构造一次string。另一种构造缓存的方法是在缓存中存放string对象。对象的构造过程可以只放在构造函数和put中进行，这样可以有效提高get的速度，而put的速度有所下降，我按这个策略写的代码在跑Large数据集的时候效果不错。也可以不在put中构造缓存，而是在get中构造，先查缓存，如果缓存中没有就从文件读取char，构造string并存入缓存，然后返回string，这个策略试下来，get速度降低很显著。


